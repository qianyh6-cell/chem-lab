<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>金刚石晶体 - 高亮线条版</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #0f0f0f; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 340px;
            background: rgba(20, 20, 20, 0.9);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
        }
        h1 { font-size: 1.2rem; margin-top: 0; color: #00ffff; text-shadow: 0 0 5px rgba(0,255,255,0.5); border-bottom: 1px solid #333; padding-bottom: 10px; }
        p { font-size: 0.9rem; line-height: 1.5; color: #ddd; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem; color: #fff;}
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00ffff; }
        
        .legend { display: flex; align-items: center; margin-top: 8px; font-size: 0.85rem; }
        .dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; display: inline-block; }
        .dot-frame { background: #dddddd; border: 1px solid #fff; }
        .dot-inner { background: #00ffff; box-shadow: 0 0 8px #00ffff; }
        
        .line-legend { width: 20px; height: 2px; margin-right: 10px; display: inline-block; }
        .line-a { background: white; box-shadow: 0 0 5px white; }
        .line-b { background: #00ffff; box-shadow: 0 0 5px #00ffff; }

        .info-box {
            background: #222;
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.85rem;
            border-left: 3px solid #fff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui-panel">
        <h1>金刚石晶体 (高亮版)</h1>
        
        <div class="control-group">
            <label for="explode-slider">拆解视图 (Explode):</label>
            <input type="range" id="explode-slider" min="0" max="2.5" step="0.01" value="0">
        </div>

        <div class="control-group">
            <label>图例说明：</label>
            <div class="legend"><span class="line-legend line-a"></span> A型块轮廓 (空)</div>
            <div class="legend"><span class="line-legend line-b"></span> B型块轮廓 (实)</div>
            <div class="legend"><span class="dot dot-frame"></span> FCC骨架原子</div>
            <div class="legend"><span class="dot dot-inner"></span> 四面体填隙原子</div>
        </div>

        <div class="info-box">
            <p><strong>棱线增强：</strong></p>
            <p>现在可以清晰地看到将晶胞分割为8个小立方体的<strong>明亮边界</strong>。</p>
            <p>即使在深色背景下，A块与B块的空间界限也一目了然。</p>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- 1. 初始化场景 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505); // 更深邃的黑背景，衬托亮线
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 16);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); // 提高清晰度
    renderer.shadowMap.enabled = true;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 灯光增强
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // 补光，让阴影不至于死黑
    const fillLight = new THREE.DirectionalLight(0x0044ff, 0.5);
    fillLight.position.set(-5, 0, -5);
    scene.add(fillLight);

    // --- 2. 材质定义 (高亮升级) ---
    const atomRadius = 0.35;
    
    // 骨架原子：亮银色
    const atomMatFrame = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, roughness: 0.4, metalness: 0.8 
    });
    
    // 内部原子：高亮青色，带自发光
    const atomMatInner = new THREE.MeshStandardMaterial({ 
        color: 0x00ffff, roughness: 0.2, metalness: 0.1, 
        emissive: 0x008888, emissiveIntensity: 0.8 
    });
    
    const bondMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5 });

    // --- 关键修改：高亮线条材质 ---
    // A型块线条：亮白色
    const wireMatA = new THREE.LineBasicMaterial({ 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0.5  // 稍微透明一点，不抢原子风头
    });

    // B型块线条：亮青色 (强调它内部有东西)
    const wireMatB = new THREE.LineBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 0.8, // 更亮，更实
        linewidth: 2  // 注意：WebGL在很多Windows浏览器限制线宽为1，但颜色亮就够了
    });

    // 大边框虚线材质
    const dashedMat = new THREE.LineDashedMaterial({
        color: 0x444444,
        dashSize: 0.2,
        gapSize: 0.2,
        opacity: 0.3,
        transparent: true
    });

    const atomGeo = new THREE.SphereGeometry(atomRadius, 32, 32);

    // --- 3. 核心逻辑 ---

    function createAtom(pos, material) {
        const mesh = new THREE.Mesh(atomGeo, material);
        mesh.position.copy(pos);
        mesh.castShadow = true;
        return mesh;
    }

    function createBond(p1, p2) {
        const direction = new THREE.Vector3().subVectors(p2, p1);
        const length = direction.length();
        if (length > 2.0) return null;

        const cylinderGeo = new THREE.CylinderGeometry(0.08, 0.08, length, 8);
        const bond = new THREE.Mesh(cylinderGeo, bondMat);
        bond.position.copy(p1).add(direction.multiplyScalar(0.5));
        bond.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
        return bond;
    }

    // FCC 节点判断 (保留上一版正确的逻辑)
    function isFCCNode(x, y, z) {
        const isHalf = (v) => Math.abs(v - 0.5) < 0.01;
        let halfCount = 0;
        if (isHalf(x)) halfCount++;
        if (isHalf(y)) halfCount++;
        if (isHalf(z)) halfCount++;
        // 仅顶点(0个0.5)和面心(2个0.5)有原子
        return (halfCount === 0 || halfCount === 2);
    }

    // 创建静态大边框 (Reference Box)
    function createReferenceBox(size) {
        const geometry = new THREE.BoxGeometry(size, size, size);
        const edges = new THREE.EdgesGeometry(geometry);
        const lines = new THREE.LineSegments(edges, dashedMat);
        lines.computeLineDistances(); // 必须调用才能显示虚线
        return lines;
    }

    /**
     * 创建小立方体 (Octant)
     */
    function createOctant(gx, gy, gz, type, fullSize) {
        const group = new THREE.Group();
        const halfSize = fullSize / 2;
        
        // --- 1. 绘制高亮边框 ---
        const boxGeo = new THREE.BoxGeometry(halfSize, halfSize, halfSize);
        const edges = new THREE.EdgesGeometry(boxGeo);
        
        // 根据类型选择材质
        const mat = (type === 'B') ? wireMatB : wireMatA;
        const wireframe = new THREE.LineSegments(edges, mat);
        
        wireframe.position.set(halfSize/2, halfSize/2, halfSize/2);
        group.add(wireframe);

        // --- 2. 绘制原子 ---
        const validCorners = []; 

        for(let lx=0; lx<=1; lx++) {
            for(let ly=0; ly<=1; ly++) {
                for(let lz=0; lz<=1; lz++) {
                    const localX = lx * halfSize;
                    const localY = ly * halfSize;
                    const localZ = lz * halfSize;

                    // 归一化坐标计算
                    const normX = (gx * 0.5) + (lx * 0.5);
                    const normY = (gy * 0.5) + (ly * 0.5);
                    const normZ = (gz * 0.5) + (lz * 0.5);

                    if (isFCCNode(normX, normY, normZ)) {
                        const pos = new THREE.Vector3(localX, localY, localZ);
                        group.add(createAtom(pos, atomMatFrame));
                        validCorners.push(pos);
                    }
                }
            }
        }

        // --- 3. 绘制 B型 内部填隙 ---
        if (type === 'B') {
            const centerX = halfSize / 2;
            const centerY = halfSize / 2;
            const centerZ = halfSize / 2;
            const centerPos = new THREE.Vector3(centerX, centerY, centerZ);
            
            group.add(createAtom(centerPos, atomMatInner));

            validCorners.forEach(cornerPos => {
                const bond = createBond(centerPos, cornerPos);
                if(bond) group.add(bond);
            });
        }

        // 定位
        const globalOffsetX = gx * halfSize - fullSize/2;
        const globalOffsetY = gy * halfSize - fullSize/2;
        const globalOffsetZ = gz * halfSize - fullSize/2;

        group.position.set(globalOffsetX, globalOffsetY, globalOffsetZ);
        
        // 动画数据
        const centerOfBlock = new THREE.Vector3(halfSize/2, halfSize/2, halfSize/2);
        const worldCenter = centerOfBlock.clone().add(group.position);
        
        group.userData = {
            initialPos: group.position.clone(),
            explodeDir: worldCenter.normalize() 
        };

        return group;
    }

    // --- 4. 组装 ---
    const FULL_SIZE = 4; 
    
    // 添加一个静态的原始边框参照，这样炸开后知道原来的框在哪
    scene.add(createReferenceBox(FULL_SIZE));

    const octants = [];

    for (let x = 0; x < 2; x++) {
        for (let y = 0; y < 2; y++) {
            for (let z = 0; z < 2; z++) {
                const sum = x + y + z;
                // 偶数为B(填)，奇数为A(空)
                const type = (sum % 2 === 0) ? 'B' : 'A';
                
                const octant = createOctant(x, y, z, type, FULL_SIZE);
                scene.add(octant);
                octants.push(octant);
            }
        }
    }

    // --- 5. 交互 ---
    const slider = document.getElementById('explode-slider');
    
    slider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        octants.forEach(grp => {
            const init = grp.userData.initialPos;
            const dir = grp.userData.explodeDir;
            grp.position.copy(init).add(dir.clone().multiplyScalar(val));
        });
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
